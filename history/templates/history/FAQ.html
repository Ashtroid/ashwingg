{% load static %}
<!DOCTYPE html>
<html>
	<head>
		<title>Ashwin.gg</title>
		<link rel="shortcut icon" type="image/png" href="{% static 'logo.png' %}"/>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
		<link rel="stylesheet" type="text/css" href="{% static 'history/style.css' %}">
	</head>
	<body>
		{% include "history/navbar.html" %}
		<div class = "FAQ">
			<div class = "heading">Our Mission</div>
			<p>
				Ashwin.gg is a League of Legends match history visualizer, using the <a href="https://developer.riotgames.com/apis" target="_blank">API</a> provided by Riot Games to neatly display all <b>Ranked Solo/Duo Queue</b> games by username. We provide a minimal approach to displaying all the information needed to judge a game without all the clutter. All the code for this project can be found <a href="https://github.com/ashtroid/ashwingg" target="_blank">here</a>.
			</p>
			<div class = "heading">Technical Details</div>
			<p>
				Our website is powered by Django, which allows us to use Python as the backend. Python calls the Riot API and parses summoner info. The view renders the template, built on basic HTML, CSS, Javascript combo - with the help of Bootstrap and JQuery - with summoner info based on their Ranked Solo/Duo Queue games. Jquery handles AJAX requests, which uses a POST function to call the Python backend using a View class, and returns a rendered String that is used to display the matches, batched at a capacity of 5 at a time. Matches are indexed by matchId, which are then stored in the SQLite database, and upon compute, check against the database to avoid recomputation for much faster load times and reduced server load. The server itself is run on an Ubuntu EC2 instance, which uses Nginx is the Load Balancer and reverse proxy, and Route 53 as the DNS provider. The job handling is done by Supervisor running 3 Gunicorn workers, which is the cap of the EC2 instance. The website is configured to only run through SSL, powered by a LetsEncrypt cert/key pair. We also use standard Django headers to provide rate limiting to avoid throttling and csrf protection for security.
			</p>
		</div>
	</body>
</html>