{% extends 'history/base_template.html' %}
{% load static %}
{% block content %}
<div class="bg-dark-blue text-light text-center">
	<div class="container">
		<div class="row">
			<h1 class="col p-3"> 
				Frequently Asked Questions
			</h1>
		</div>
	<!--<img src="{% static 'koala.png' %}" height=200px width=200px/>-->
	</div>
</div>
<div class="font-weight-light text-dark">
	<div class="container">
		<div class="row">
			<div class="col p-3">
				<h5 class="text-dark">Our Mission</h5>
				<p>
					Ashwin.gg is a League of Legends Match History Visualizer, using the <a href="https://developer.riotgames.com/apis" target="_blank">API</a> provided by Riot Games to neatly display all <b>Ranked Solo/Duo Queue</b> games by username. We provide a minimal approach to displaying all the information needed to judge a game without all the clutter. All the code for this project can be found <a href="https://github.com/ashtroid/ashwingg" target="_blank">here</a>.
				</p>
				<h5 class="text-dark">Technical Details</h5>
				<p>
					Our website is powered by Django, which allows us to use Python as the backend. Python calls the Riot API and parses summoner info. The view renders the template, built on basic HTML, CSS, Javascript combo - with the help of Bootstrap and JQuery - with summoner info based on their Ranked Solo/Duo Queue games. Jquery handles AJAX requests, which uses a POST function to call the Python backend using a View class, and returns a rendered String that is used to display the matches, batched at a capacity of 5 at a time. This uses multiprocessing, with a pool size 5 to match the batch size. Matches are indexed by matchId, which are then stored in the SQLite database, and upon compute, check against the database to avoid recomputation for much faster load times and reduced server load. The server itself is run on an Ubuntu EC2 instance, which uses Nginx is the Load Balancer and reverse proxy, and Route 53 as the DNS provider. The job handling is done by Supervisor running 3 Gunicorn workers, which is the cap of the EC2 instance. The website is configured to only run through SSL, powered by a LetsEncrypt cert/key pair. We also use standard Django headers to provide rate limiting to avoid throttling and csrf protection for security, with Memcached used as in-memory caching to store the rate limiter keys. Static files are served via CDN, built on CloudFront and S3.
				</p>
			</div>
		</div>
	</div>
</div>
{% endblock %}